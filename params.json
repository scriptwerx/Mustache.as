{"name":"Mustache.as","tagline":"Logic-less {{mustache}} templates with ActionScript 3.0","body":"# mustache.as - Logic-less {{mustache}} templates with ActionScript 3.0\r\n---\r\n\r\n[Mustache.as](http://scriptwerx.github.io/Mustache.as) is a conversion into ActionScript 3.0 of [mustache.js](http://github.com/janl/mustache.js) (specifically v0.7.2) which in turn is an implementation of the [mustache](http://mustache.github.com/) template system in JavaScript.\r\n\r\nI compiled this version as the previous [ActionScript 3.0 port by Jos Yule](https://github.com/hyakugei/mustache.as) is very old and hasn't been updated in many years.\r\n\r\n[Mustache](http://mustache.github.com/) is a logic-less template syntax. It can be used for HTML, config files, source code - anything. It works by expanding tags in a template using values provided in a hash or object.\r\n\r\nWe call it \"logic-less\" because there are no if statements, else clauses, or for loops. Instead there are only tags. Some tags are replaced with a value, some nothing, and others a series of values.\r\n\r\nFor a language-agnostic overview of mustache's template syntax, see the `mustache(5)` [manpage](http://mustache.github.com/mustache.5.html).\r\n\r\n## Where to use mustache.as?\r\n\r\nYou can use mustache.as to render mustache templates in your Flash, Flex and Air projects.\r\n\r\n## Usage\r\n\r\nBelow is quick example how to use mustache.js:\r\n\r\n\timport uk.co.scriptwerx.mustache.Mustache;\r\n\r\n    var view = {\r\n      title: \"Joe\",\r\n      calc: function () {\r\n        return 2 + 4;\r\n      }\r\n    };\r\n    \r\n    var mustache:Mustache = new Mustache ();\r\n    var output:String = mustache.render (\"{{title}} spends {{calc}}\", view);\r\n\r\nIn this example, the `Mustache.render` function takes two parameters: 1) the [mustache](http://mustache.github.com/) template and 2) a `view` object that contains the data and code needed to render the template.\r\n\r\n## Templates\r\n\r\nA [mustache](http://mustache.github.com/) template is a string that contains any number of mustache tags. Tags are indicated by the double mustaches that surround them. `{{person}}` is a tag, as is `{{#person}}`. In both examples we refer to `person` as the tag's key.\r\n\r\nThere are several types of tags available in mustache.js.\r\n\r\n### Variables\r\n\r\nThe most basic tag type is a simple variable. A `{{name}}` tag renders the value of the `name` key in the current context. If there is no such key, nothing is rendered.\r\n\r\nAll variables are HTML-escaped by default. If you want to render unescaped HTML, use the triple mustache: `{{{name}}}`. You can also use `&` to unescape a variable.\r\n\r\nView:\r\n\r\n    {\r\n      \"name\": \"Chris\",\r\n      \"company\": \"<b>GitHub</b>\"\r\n    }\r\n\r\nTemplate:\r\n\r\n    * {{name}}\r\n    * {{age}}\r\n    * {{company}}\r\n    * {{{company}}}\r\n    * {{&company}}\r\n\r\nOutput:\r\n\r\n    * Chris\r\n    *\r\n    * &lt;b&gt;GitHub&lt;/b&gt;\r\n    * <b>GitHub</b>\r\n    * <b>GitHub</b>\r\n\r\nJavaScript's dot notation may be used to access keys that are properties of objects in a view.\r\n\r\nView:\r\n\r\n    {\r\n      \"name\": {\r\n        \"first\": \"Clem\",\r\n        \"last\": \"Alice\"\r\n      },\r\n      \"age\": \"RIP\"\r\n    }\r\n\r\nTemplate:\r\n\r\n    * {{name.first}} {{name.last}}\r\n    * {{age}}\r\n\r\nOutput:\r\n\r\n    * Clem Alice\r\n    * RIP\r\n\r\n### Sections\r\n\r\nSections render blocks of text one or more times, depending on the value of the key in the current context.\r\n\r\nA section begins with a pound and ends with a slash. That is, `{{#person}}` begins a `person` section, while `{{/person}}` ends it. The text between the two tags is referred to as that section's \"block\".\r\n\r\nThe behavior of the section is determined by the value of the key.\r\n\r\n#### False Values or Empty Lists\r\n\r\nIf the `person` key does not exist, or exists and has a value of `null`, `undefined`, or `false`, or is an empty list, the block will not be rendered.\r\n\r\nView:\r\n\r\n    {\r\n      \"person\": false\r\n    }\r\n\r\nTemplate:\r\n\r\n    Shown.\r\n    {{#person}}\r\n    Never shown!\r\n    {{/person}}\r\n\r\nOutput:\r\n\r\n    Shown.\r\n\r\n#### Non-Empty Lists\r\n\r\nIf the `person` key exists and is not `null`, `undefined`, or `false`, and is not an empty list the block will be rendered one or more times.\r\n\r\nWhen the value is a list, the block is rendered once for each item in the list. The context of the block is set to the current item in the list for each iteration. In this way we can loop over collections.\r\n\r\nView:\r\n\r\n    {\r\n      \"stooges\": [\r\n        { \"name\": \"Moe\" },\r\n        { \"name\": \"Larry\" },\r\n        { \"name\": \"Curly\" }\r\n      ]\r\n    }\r\n\r\nTemplate:\r\n\r\n    {{#stooges}}\r\n    <b>{{name}}</b>\r\n    {{/stooges}}\r\n\r\nOutput:\r\n\r\n    <b>Moe</b>\r\n    <b>Larry</b>\r\n    <b>Curly</b>\r\n\r\nWhen looping over an array of strings, a `.` can be used to refer to the current item in the list.\r\n\r\nView:\r\n\r\n    {\r\n      \"musketeers\": [\"Athos\", \"Aramis\", \"Porthos\", \"D'Artagnan\"]\r\n    }\r\n\r\nTemplate:\r\n\r\n    {{#musketeers}}\r\n    * {{.}}\r\n    {{/musketeers}}\r\n\r\nOutput:\r\n\r\n    * Athos\r\n    * Aramis\r\n    * Porthos\r\n    * D'Artagnan\r\n\r\n### Inverted Sections\r\n\r\nAn inverted section opens with `{{^section}}` instead of `{{#section}}`. The block of an inverted section is rendered only if the value of that section's tag is `null`, `undefined`, `false`, or an empty list.\r\n\r\nView:\r\n\r\n    {\r\n      \"repos\": []\r\n    }\r\n\r\nTemplate:\r\n\r\n    {{#repos}}<b>{{name}}</b>{{/repos}}\r\n    {{^repos}}No repos :({{/repos}}\r\n\r\nOutput:\r\n\r\n    No repos :(\r\n\r\n### Comments\r\n\r\nComments begin with a bang and are ignored. The following template:\r\n\r\n    <h1>Today{{! ignore me }}.</h1>\r\n\r\nWill render as follows:\r\n\r\n    <h1>Today.</h1>\r\n\r\nComments may contain newlines.\r\n\r\n### Partials\r\n\r\nPartials begin with a greater than sign, like {{> box}}.\r\n\r\nPartials are rendered at runtime (as opposed to compile time), so recursive partials are possible. Just avoid infinite loops.\r\n\r\nThey also inherit the calling context. Whereas in ERB you may have this:\r\n\r\n    <%= partial :next_more, :start => start, :size => size %>\r\n\r\nMustache requires only this:\r\n\r\n    {{> next_more}}\r\n\r\nWhy? Because the `next_more.mustache` file will inherit the `size` and `start` variables from the calling context. In this way you may want to think of partials as includes, or template expansion, even though it's not literally true.\r\n\r\nFor example, this template and partial:\r\n\r\n    base.mustache:\r\n    <h2>Names</h2>\r\n    {{#names}}\r\n      {{> user}}\r\n    {{/names}}\r\n\r\n    user.mustache:\r\n    <strong>{{name}}</strong>\r\n\r\nCan be thought of as a single, expanded template:\r\n\r\n    <h2>Names</h2>\r\n    {{#names}}\r\n      <strong>{{name}}</strong>\r\n    {{/names}}\r\n\r\nIn mustache.js an object of partials may be passed as the third argument to `Mustache.render`. The object should be keyed by the name of the partial, and its value should be the partial text.\r\n\r\n### Set Delimiter\r\n\r\nSet Delimiter tags start with an equals sign and change the tag delimiters from `{{` and `}}` to custom strings.\r\n\r\nConsider the following contrived example:\r\n\r\n    * {{ default_tags }}\r\n    {{=<% %>=}}\r\n    * <% erb_style_tags %>\r\n    <%={{ }}=%>\r\n    * {{ default_tags_again }}\r\n\r\nHere we have a list with three items. The first item uses the default tag style, the second uses ERB style as defined by the Set Delimiter tag, and the third returns to the default style after yet another Set Delimiter declaration.\r\n\r\nAccording to [ctemplates](http://google-ctemplate.googlecode.com/svn/trunk/doc/howto.html), this \"is useful for languages like TeX, where double-braces may occur in the text and are awkward to use for markup.\"\r\n\r\nCustom delimiters may not contain whitespace or the equals sign.\r\n\r\n### Compiled Templates\r\n\r\nMustache templates can be compiled into JavaScript functions using `mustache.compile` for improved rendering performance.\r\n\r\nIf you have template views that are rendered multiple times, compiling your template into a JavaScript function will minimise the amount of work required for each re-render.\r\n\r\nPre-compiled templates can also be generated server-side, for delivery to the browser as ready to use JavaScript functions, further reducing the amount of client side processing required for initialising templates.\r\n\r\n**Mustache.compile**\r\n\r\nUse `mustache.compile` to compile standard Mustache string templates into reusable Mustache template functions.\r\n\r\n\timport uk.co.scriptwerx.mustache.Mustache;\r\n\r\n\tvar mustache:Mustache = new Mustache ();\r\n    var compiledTemplate = mustache.compile (stringTemplate);\r\n\r\nThe function returned from `mustache.compile` can then be called directly, passing in the template data as an argument (with an object of partials as an optional second parameter), to generate the final output.\r\n\r\n    var templateOutput:String = compiledTemplate (templateData);\r\n\r\n**Mustache.compilePartial**\r\n\r\nTemplate partials can also be compiled using the `Mustache.compilePartial` function. The first parameter of this function, is the name of the partial as it appears within parent templates.\r\n\r\n\timport uk.co.scriptwerx.mustache.Mustache;\r\n\r\n\tvar mustache:Mustache = new Mustache ();\r\n    mustache.compilePartial ('partial-name', stringTemplate);\r\n\r\nCompiled partials are then available to both `Mustache.render` and `Mustache.compile`.\r\n\r\n&nbsp;\r\n___\r\n&nbsp;\r\n","google":"UA-30660100-3","note":"Don't delete this file! It's used internally to help with page regeneration."}